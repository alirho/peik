# مستندات معماری گوگ (Goug AI Chat)

این سند معماری سطح بالای برنامه چت گوگ، تصمیمات کلیدی طراحی و جریان داده در سیستم را تشریح می‌کند. هدف این است که به توسعه‌دهندگان درک عمیقی از ساختار پروژه بدهد تا بتوانند به طور مؤثر آن را نگهداری و گسترش دهند.

## 1. نمای کلی معماری (Architectural Overview)

برنامه از یک **معماری سه لایه و رویداد-محور (Event-Driven)** در فرانت‌اند پیروی می‌کند. این سه لایه اصلی عبارتند از:

1.  **لایه رابط کاربری (UI Layer)**: مسئولیت تمام جنبه‌های بصری و تعامل با کاربر را بر عهده دارد.
2.  **لایه هسته (Core Layer)**: مغز متفکر برنامه است که منطق اصلی، مدیریت وضعیت و ارتباط با APIهای خارجی را مدیریت می‌کند.
3.  **لایه سرویس‌ها (Services Layer)**: ابزارهای کمکی و انتزاعی را برای نگرانی‌های جانبی مانند ارتباطات شبکه، **پیاده‌سازی‌های ذخیره‌سازی** و پردازش Markdown فراهم می‌کند.

### نمودار معماری

```
+-----------------------------------------------------------------+
| کاربر (User)                                                    |
+-----------------------------------------------------------------+
      ^                                      |
      | User Interactions (clicks, input)      | DOM Updates (render)
      v                                      |
+-----------------------------------------------------------------+
| لایه رابط کاربری (UI Layer)                                     |
| [chatUI.js, messageRenderer.js, sidebarManager.js, ...]         |
| - رندر کردن پیام‌ها، لیست چت‌ها و کامپوننت‌ها                      |
| - دریافت ورودی‌های کاربر (متن و تصویر)                          |
| - فراخوانی متدهای عمومی ChatEngine                               |
| - گوش دادن به رویدادهای ChatEngine                               |
+-----------------------------------------------------------------+
      ^                                      |
      | Calls `chatEngine.sendMessage()`     | Emits Events (`message`, `chunk`, `error`)
      | `chatEngine.switchActiveChat()`      |
      v                                      |
+-----------------------------------------------------------------+
| لایه هسته (Core Layer)                                          |
| [chatEngine.js, eventEmitter.js, providers/*.js]                |
| - مدیریت وضعیت (لیست چت‌ها، چت فعال، isLoading)                 |
| - ارکستراسیون و انتخاب Provider مناسب                           |
| - دریافت یک "آداپتور ذخیره‌سازی" برای پایداری داده‌ها (تزریق وابستگی) |
| - انتشار رویدادها برای اطلاع‌رسانی به UI Layer                   |
+-----------------------------------------------------------------+
      |                                      ^
      | Calls `storage.saveChat()` / `apiService.fetch()` | Returns Data
      v                                      |
+-----------------------------------------------------------------+
| لایه سرویس‌ها (Services Layer)                                   |
| [apiService.js, storageService.js, memoryStorage.js, ...]       |
| - انتزاعی‌سازی ارتباط با APIهای خارجی (fetch)                    |
| - ارائه پیاده‌سازی‌های مختلف برای ذخیره‌سازی داده‌ها               |
| - پردازش و رندر متن Markdown                                    |
+-----------------------------------------------------------------+
```

## 2. تشریح لایه‌ها

### 2.1. لایه رابط کاربری (UI Layer)

این لایه کاملاً از منطق اصلی برنامه جداست. وظیفه آن صرفاً نمایش داده‌ها و ارسال دستورات کاربر به لایه هسته است.

-   **مسئولیت‌ها**:
    -   بارگذاری قالب‌های HTML و رندر کردن کامپوننت‌ها در DOM.
    -   گرفتن رویدادهای کاربر (مانند کلیک روی دکمه ارسال، انتخاب یک چت، و انتخاب فایل تصویر).
    -   پردازش تصویر در کلاینت: خواندن فایل، نمایش پیش‌نمایش، و فشرده‌سازی.
    -   فراخوانی متدهای عمومی `chatEngine` برای اجرای منطق برنامه.
    -   **اشتراک (Subscribe)** در رویدادهایی که توسط `chatEngine` منتشر می‌شود و به‌روزرسانی DOM بر اساس آن‌ها.
-   **کامپوننت‌های کلیدی**: `chatUI.js`, `messageRenderer.js`, `settingsModal.js`, `sidebarManager.js`.

### 2.2. لایه هسته (Core Layer)

این لایه قلب تپنده برنامه است و هیچ وابستگی مستقیمی به DOM یا یک مکانیزم ذخیره‌سازی خاص ندارد.

-   **مسئولیت‌ها**:
    -   نگهداری وضعیت کلی برنامه (آرایه‌ای از `chats`، شناسه `activeChatId`، وضعیت `isLoading` و `settings`).
    -   **تزریق وابستگی (Dependency Injection)**: دریافت یک **آداپتور ذخیره‌سازی** در `constructor` خود. اگر آداپتوری ارائه نشود، از یک پیاده‌سازی پیش‌فرض در حافظه (`MemoryStorage`) استفاده می‌کند.
    -   فراخوانی متدهای آداپتور ذخیره‌سازی (`this.storage.saveChat()`, `this.storage.loadAllChats()`).
    -   استفاده از **الگوی استراتژی (Strategy Pattern)** برای انتخاب `Provider` مناسب (Gemini, OpenAI, و غیره).
    -   **انتشار (Publish)** رویدادها از طریق `EventEmitter` برای اطلاع‌رسانی به لایه‌های دیگر.
-   **کامپوننت‌های کلیدی**: `chatEngine.js`, `eventEmitter.js`, و تمام فایل‌های موجود در `providers/`.

### 2.3. لایه سرویس‌ها (Services Layer)

این لایه شامل ماژول‌های عمومی و قابل استفاده مجدد است که وظایف خاص و جانبی را انجام می‌دهند.

-   **مسئولیت‌ها**:
    -   **`storageService.js`**: یک **پیاده‌سازی** از رابط ذخیره‌سازی است که از `IndexedDB` استفاده می‌کند. این ماژول در نسخه وب به `ChatEngine` تزریق می‌شود.
    -   **`memoryStorage.js`**: پیاده‌سازی دیگری از رابط ذخیره‌سازی که داده‌ها را در حافظه موقت (RAM) نگه می‌دارد.
    -   **`apiService.js`**: مدیریت تمام ارتباطات شبکه با APIهای خارجی.
    -   **`markdownService.js`**: کپسوله کردن منطق پردازش و رندر متن Markdown به HTML.
-   **کامپوننت‌های کلیدی**: `apiService.js`, `storageService.js`, `memoryStorage.js`, `markdownService.js`.

## 3. معماری رویداد-محور (Event-Driven Architecture)

ارتباط اصلی بین `Core Layer` و `UI Layer` از طریق یک سیستم **Publish/Subscribe** ساده (پیاده‌سازی شده در `eventEmitter.js`) انجام می‌شود.

-   **مزایا**:
    -   **جداسازی کامل (Decoupling)**: `Core Layer` هیچ اطلاعی از نحوه نمایش داده‌ها ندارد. این به ما اجازه می‌دهد تا هر لایه را به صورت مستقل تغییر دهیم.

## 4. نمودار جریان یک درخواست (Request Flow Diagram)

این نمودار، مراحل کامل از زمان ارسال پیام توسط کاربر تا نمایش پاسخ را نشان می‌دهد:

```
User ---[1. تایپ پیام و ارسال]---> [ChatUI]
  |
  +-----[2. فراخوانی `chatEngine.sendMessage(text, image)`]---> [ChatEngine]
                                                                 |
  +<----[3. انتشار رویداد `loading(true)` و `message(userMessage)`]--+
  |                                                              |
[UI به‌روزرسانی می‌شود: دکمه غیرفعال، پیام کاربر نمایش داده می‌شود] |
                                                                 V
                                                          [Provider Selector]
                                                                 |
  +-----[4. انتخاب Provider مناسب]---> [GeminiProvider / OpenAIProvider]
                                                                 |
  +-----[5. فراخوانی `apiService.fetchStreamWithRetries()`]---> [ApiService]
                                                                 |
                                                  [6. ارسال درخواست به API]
                                                                 |
  +<----[7. دریافت قطعات استریم (Chunks)]-------------------------+
  |                                                              |
[ApiService] ---[8. پردازش و ارسال Chunk به Callback]---> [Provider]
                                                                 |
  +<----[9. `onChunk(chunk)` فراخوانی می‌شود]---------------------+
  |                                                              |
[ChatEngine] ---[10. انتشار رویداد `chunk(text)`]---> [EventEmitter]
                                                                 |
  +<----[11. `messageRenderer` رویداد را دریافت می‌کند]------------+
  |
[messageRenderer متن را رندر کرده و DOM را به‌روزرسانی می‌کند]

... (مراحل 7 تا 11 برای هر Chunk تکرار می‌شود) ...

[ApiService] ---[12. استریم تمام می‌شود]---> [ChatEngine]
                                                |
  +-----[13. ذخیره چت `this.storage.saveChat()`]--+
  |                                                |
  +<---[14. انتشار `loading(false)` و `streamEnd`]-+
  |
[UI به‌روزرسانی می‌شود: دکمه فعال می‌شود]
```

## 5. تصمیمات طراحی و چرایی آن‌ها

-   **Vanilla JS**: برای سبک نگه داشتن پروژه، کاهش وابستگی‌ها و اطمینان از حداکثر کارایی انتخاب شده است.
-   **ماژول‌های ES6**: برای سازماندهی بهتر کد، جداسازی مسئولیت‌ها و قابلیت نگهداری بالا.
-   **جداسازی UI از Core**: این مهم‌ترین تصمیم معماری است که اجازه می‌دهد منطق برنامه در محیط‌های مختلف (مرورگر، Node.js) بدون تغییر استفاده شود.
-   **آداپتور ذخیره‌سازی (Storage Adapter Pattern)**: به جای وابستگی مستقیم به `IndexedDB`، هسته برنامه یک رابط (Interface) ذخیره‌سازی را انتظار دارد. این کار باعث می‌شود بتوان به راحتی مکانیزم ذخیره‌سازی را بدون تغییر در هسته، تعویض کرد. این یک نمونه عالی از **تزریق وابستگی (Dependency Injection)** است.
-   **مدیریت چندین چت**: به جای یک تاریخچه واحد، برنامه مجموعه‌ای از اشیاء چت را مدیریت می‌کند. این کار پیچیدگی مدیریت وضعیت را افزایش می‌دهد اما تجربه کاربری بسیار بهتری را فراهم می‌کند.