# مستندات معماری گوگ (Goug AI Chat)

این سند معماری سطح بالای برنامه چت گوگ، تصمیمات کلیدی طراحی و جریان داده در سیستم را تشریح می‌کند. هدف این است که به توسعه‌دهندگان درک عمیقی از ساختار پروژه بدهد تا بتوانند به طور مؤثر آن را نگهداری و گسترش دهند.

## 1. نمای کلی معماری (Architectural Overview)

برنامه از یک **معماری سه لایه و رویداد-محور (Event-Driven)** در فرانت‌اند پیروی می‌کند. این سه لایه اصلی عبارتند از:

1.  **لایه رابط کاربری (UI Layer)**: مسئولیت تمام جنبه‌های بصری و تعامل با کاربر را بر عهده دارد.
2.  **لایه هسته (Core Layer)**: مغز متفکر برنامه است که منطق اصلی، مدیریت وضعیت و ارتباط با APIهای خارجی را مدیریت می‌کند.
3.  **لایه سرویس‌ها (Services Layer)**: ابزارهای کمکی و انتزاعی را برای نگرانی‌های جانبی مانند ارتباطات شبکه، ذخیره‌سازی و پردازش Markdown فراهم می‌کند.

### نمودار معماری

```
+-----------------------------------------------------------------+
| کاربر (User)                                                    |
+-----------------------------------------------------------------+
      ^                                      |
      | User Interactions (clicks, input, file selection) | DOM Updates (render)
      v                                      |
+-----------------------------------------------------------------+
| لایه رابط کاربری (UI Layer)                                     |
| [chatUI.js, messageRenderer.js, sidebarManager.js, ...]         |
| - رندر کردن پیام‌ها، لیست چت‌ها و کامپوننت‌ها                      |
| - دریافت ورودی‌های کاربر (متن و تصویر)                          |
| - فشرده‌سازی تصویر و مدیریت پیش‌نمایش                            |
| - فراخوانی متدهای عمومی Core Layer                              |
| - گوش دادن به رویدادهای Core Layer                                |
+-----------------------------------------------------------------+
      ^                                      |
      | Calls `chatEngine.sendMessage(text, image)` | Emits Events (`message`, `chunk`, `error`)
      | `chatEngine.switchActiveChat()`      |
      v                                      |
+-----------------------------------------------------------------+
| لایه هسته (Core Layer)                                          |
| [chatEngine.js, eventEmitter.js, providers/*.js]                |
| - مدیریت وضعیت (لیست چت‌ها، چت فعال، isLoading)                 |
| - ارکستراسیون و انتخاب Provider مناسب                           |
| - افزودن پیام چندرسانه‌ای به تاریخچه                             |
| - انتشار رویدادها برای اطلاع‌رسانی به UI Layer                   |
+-----------------------------------------------------------------+
      |                                      ^
      | Calls API / Storage / Markdown methods | Returns Data
      v                                      |
+-----------------------------------------------------------------+
| لایه سرویس‌ها (Services Layer)                                   |
| [apiService.js, storageService.js, markdownService.js]          |
| - انتزاعی‌سازی ارتباط با APIهای خارجی (fetch)                    |
- مدیریت ذخیره‌سازی محلی (IndexedDB)                            |
| - پردازش و رندر متن Markdown                                    |
+-----------------------------------------------------------------+
```

## 2. تشریح لایه‌ها

### 2.1. لایه رابط کاربری (UI Layer)

این لایه کاملاً از منطق اصلی برنامه جداست. وظیفه آن صرفاً نمایش داده‌ها و ارسال دستورات کاربر به لایه هسته است.

-   **مسئولیت‌ها**:
    -   بارگذاری قالب‌های HTML و رندر کردن کامپوننت‌ها در DOM.
    -   گرفتن رویدادهای کاربر (مانند کلیک روی دکمه ارسال، انتخاب یک چت، و **انتخاب فایل تصویر**).
    -   **پردازش تصویر در کلاینت**: خواندن فایل تصویر، نمایش پیش‌نمایش، و **فشرده‌سازی تصاویر حجیم** با استفاده از Canvas.
    -   مدیریت **نمای تمام‌صفحه (Lightbox)** برای تصاویر.
    -   فراخوانی متدهای عمومی `chatEngine` برای اجرای منطق برنامه (مثلاً `chatEngine.sendMessage(userInput, imageObject)`).
    -   **اشتراک (Subscribe)** در رویدادهایی که توسط `chatEngine` منتشر می‌شود و به‌روزرسانی DOM بر اساس آن‌ها (مثلاً نمایش پیام جدید با تصویر، نمایش انیمیشن بارگذاری تصویر).
-   **کامپوننت‌های کلیدی**: `chatUI.js`, `messageRenderer.js`, `settingsModal.js`, `sidebarManager.js`.

### 2.2. لایه هسته (Core Layer)

این لایه قلب تپنده برنامه است و هیچ وابستگی مستقیمی به DOM ندارد.

-   **مسئولیت‌ها**:
    -   نگهداری وضعیت کلی برنامه (آرایه‌ای از `chats`، شناسه `activeChatId`، وضعیت `isLoading` و `settings`).
    -   پیاده‌سازی منطق اصلی کسب‌وکار (ایجاد چت جدید، حذف چت، و **ارسال پیام چندرسانه‌ای**).
    -   استفاده از **الگوی استراتژی (Strategy Pattern)** برای انتخاب `Provider` مناسب (Gemini, OpenAI, و غیره) بر اساس تنظیمات کاربر.
    -   **ارسال داده‌های تصویر** به Provider مناسب جهت ساختاردهی برای API.
    -   **انتشار (Publish)** رویدادها از طریق `EventEmitter` برای اطلاع‌رسانی به لایه‌های دیگر (مانند `UI Layer`) در مورد تغییرات وضعیت.
-   **کامپوننت‌های کلیدی**: `chatEngine.js`, `eventEmitter.js`, و تمام فایل‌های موجود در `providers/` که اکنون منطق ساخت درخواست‌های چندرسانه‌ای را نیز شامل می‌شوند.

### 2.3. لایه سرویس‌ها (Services Layer)

این لایه شامل ماژول‌های عمومی و قابل استفاده مجدد است که وظایف خاص و جانبی را انجام می‌دهند.

-   **مسئولیت‌ها**:
    -   **`storageService.js`**: انتزاعی‌سازی عملیات خواندن و نوشتن در `IndexedDB`. این سرویس اکنون داده‌های base64 تصاویر را نیز در آبجکت پیام ذخیره می‌کند.
    -   **`apiService.js`**: مدیریت تمام ارتباطات شبکه با APIهای خارجی.
    -   **`markdownService.js`**: کپسوله کردن منطق پردازش و رندر متن Markdown به HTML.
-   **کامپوننت‌های کلیدی**: `apiService.js`, `storageService.js`, `markdownService.js`.

## 3. معماری رویداد-محور (Event-Driven Architecture)

ارتباط اصلی بین `Core Layer` و `UI Layer` از طریق یک سیستم **Publish/Subscribe** ساده (پیاده‌سازی شده در `eventEmitter.js`) انجام می‌شود. این الگو بدون تغییر باقی مانده و برای مدیریت رویدادهای مربوط به تصویر نیز به خوبی کار می‌کند.

-   **مزایا**:
    -   **جداسازی کامل (Decoupling)**: `Core Layer` هیچ اطلاعی از نحوه نمایش داده‌ها (شامل تصاویر، پیش‌نمایش‌ها یا انیمیشن‌های بارگذاری) ندارد. این به ما اجازه می‌دهد تا هر لایه را به صورت مستقل تغییر دهیم.

## 4. نمودار جریان یک درخواست (Request Flow Diagram) - با تصویر

این نمودار، مراحل کامل از زمان ارسال پیام توسط کاربر تا نمایش پاسخ را نشان می‌دهد:

```
User ---[1. انتخاب تصویر و تایپ پیام]---> [ChatUI]
  |
  |----[2. خواندن و فشرده‌سازی تصویر (در صورت نیاز)]
  |
  +-----[3. فراخوانی `chatEngine.sendMessage(text, imageObject)`]---> [ChatEngine]
                                                                        |
  +<----[4. انتشار رویداد `loading(true)` و `message(userMessage)`]-------+
  |                                                                     |
[UI به‌روزرسانی می‌شود: دکمه غیرفعال، پیام کاربر با تصویر و انیمیشن بارگذاری نمایش داده می‌شود] |
                                                                        V
                                                                [Provider Selector]
                                                                        |
  +-----[5. انتخاب Provider مناسب و ارسال داده‌های چندرسانه‌ای]---> [GeminiProvider / OpenAIProvider]
                                                                        |
  +-----[6. فراخوانی `apiService.fetchStreamWithRetries()`]---> [ApiService]
                                                                        |
                                                         [7. ارسال درخواست به API]
                                                                        |
  +<----[8. دریافت قطعات استریم (Chunks)]--------------------------------+
  |                                                                     |
[ApiService] ---[9. پردازش و ارسال Chunk به Callback]---> [Provider]
                                                                        |
  +<----[10. `onChunk(chunk)` فراخوانی می‌شود]----------------------------+
  |                                                                     |
[ChatEngine] ---[11. انتشار رویداد `chunk(text)`]---> [EventEmitter]
                                                                        |
  +<----[12. `messageRenderer` رویداد را دریافت می‌کند]-------------------+
  |
[messageRenderer متن خام را انباشته، با `markdownService` رندر کرده و `innerHTML` حباب پیام را به‌روزرسانی می‌کند]

... (مراحل 8 تا 12 برای هر Chunk تکرار می‌شود) ...

[ApiService] ---[13. استریم تمام می‌شود]---> [ChatEngine]
                                               |
  +<---[14. انتشار `loading(false)` و `streamEnd`]--+
  |
[UI به‌روزرسانی می‌شود: دکمه فعال می‌شود]
```

## 5. تصمیمات طراحی و چرایی آن‌ها

-   **Vanilla JS**: برای سبک نگه داشتن پروژه، کاهش وابستگی‌ها و اطمینان از حداکثر کارایی انتخاب شده است.
-   **ماژول‌های ES6**: برای سازماندهی بهتر کد، جداسازی مسئولیت‌ها و قابلیت نگهداری بالا.
-   **جداسازی UI از Core**: این مهم‌ترین تصمیم معماری است که با افزودن قابلیت تصویر، ارزش خود را بیشتر نشان داد. منطق پیچیده فشرده‌سازی و مدیریت DOM تصویر کاملاً در `UI Layer` باقی ماند و `Core Layer` صرفاً با یک آبجکت داده تمیز (`imageObject`) کار می‌کند.
-   **ذخیره‌سازی سمت کلاینت**: برای سادگی و عدم نیاز به بک‌اند، تمام داده‌ها (شامل تصاویر به صورت base64) در `IndexedDB` ذخیره می‌شوند. این تصمیم باعث می‌شود برنامه کاملاً ایستا باشد، اما باید به محدودیت‌های حجم `IndexedDB` توجه داشت.
-   **مدیریت چندین چت**: به جای یک تاریخچه واحد، برنامه مجموعه‌ای از اشیاء چت را مدیریت می‌کند. این کار پیچیدگی مدیریت وضعیت را افزایش می‌دهد اما تجربه کاربری بسیار بهتری را فراهم می‌کند.