# مستندات معماری گوگ (Goug AI Chat)

این سند معماری سطح بالای برنامه چت گوگ، تصمیمات کلیدی طراحی و جریان داده در سیستم را تشریح می‌کند. هدف این است که به توسعه‌دهندگان درک عمیقی از ساختار پروژه بدهد تا بتوانند به طور مؤثر آن را نگهداری و گسترش دهند.

## 1. نمای کلی معماری (Architectural Overview)

برنامه از یک **معماری سه لایه و رویداد-محور (Event-Driven)** در فرانت‌اند پیروی می‌کند. این سه لایه اصلی عبارتند از:

1.  **لایه رابط کاربری (UI Layer)**: مسئولیت تمام جنبه‌های بصری و تعامل با کاربر را بر عهده دارد.
2.  **لایه هسته (Core Layer)**: مغز متفکر برنامه است که منطق اصلی، مدیریت وضعیت و ارتباط با APIهای خارجی را مدیریت می‌کند.
3.  **لایه سرویس‌ها (Services Layer)**: ابزارهای کمکی و انتزاعی را برای نگرانی‌های جانبی مانند ارتباطات شبکه، ذخیره‌سازی و پردازش Markdown فراهم می‌کند.

### نمودار معماری

```
+-----------------------------------------------------------------+
| کاربر (User)                                                    |
+-----------------------------------------------------------------+
      ^                                      |
      | User Interactions (clicks, input)      | DOM Updates (render)
      v                                      |
+-----------------------------------------------------------------+
| لایه رابط کاربری (UI Layer)                                     |
| [chatUI.js, messageRenderer.js, sidebarManager.js, ...]         |
| - رندر کردن پیام‌ها، لیست چت‌ها و کامپوننت‌ها                      |
| - دریافت ورودی‌های کاربر                                          |
| - فراخوانی متدهای عمومی Core Layer                              |
| - گوش دادن به رویدادهای Core Layer                                |
+-----------------------------------------------------------------+
      ^                                      |
      | Calls `chatEngine.sendMessage()`       | Emits Events (`message`, `chunk`, `chatListUpdated`)
      | `chatEngine.switchActiveChat()`      |
      v                                      |
+-----------------------------------------------------------------+
| لایه هسته (Core Layer)                                          |
| [chatEngine.js, eventEmitter.js, providers/*.js]                |
| - مدیریت وضعیت (لیست چت‌ها، چت فعال، isLoading)                 |
| - ارکستراسیون و انتخاب Provider مناسب                           |
| - انتشار رویدادها برای اطلاع‌رسانی به UI Layer                   |
+-----------------------------------------------------------------+
      |                                      ^
      | Calls API / Storage / Markdown methods | Returns Data
      v                                      |
+-----------------------------------------------------------------+
| لایه سرویس‌ها (Services Layer)                                   |
| [apiService.js, storageService.js, markdownService.js]          |
| - انتزاعی‌سازی ارتباط با APIهای خارجی (fetch)                    |
| - مدیریت ذخیره‌سازی محلی (IndexedDB)                            |
| - پردازش و رندر متن Markdown                                    |
+-----------------------------------------------------------------+
```

## 2. تشریح لایه‌ها

### 2.1. لایه رابط کاربری (UI Layer)

این لایه کاملاً از منطق اصلی برنامه جداست. وظیفه آن صرفاً نمایش داده‌ها و ارسال دستورات کاربر به لایه هسته است.

-   **مسئولیت‌ها**:
    -   بارگذاری قالب‌های HTML و رندر کردن کامپوننت‌ها در DOM.
    -   گرفتن رویدادهای کاربر (مانند کلیک روی دکمه ارسال یا انتخاب یک چت از لیست).
    -   فراخوانی متدهای عمومی `chatEngine` برای اجرای منطق برنامه (مثلاً `chatEngine.sendMessage(userInput)`).
    -   **اشتراک (Subscribe)** در رویدادهایی که توسط `chatEngine` منتشر می‌شود و به‌روزرسانی DOM بر اساس آن‌ها (مثلاً نمایش پیام جدید یا رندر مجدد لیست چت‌ها).
-   **کامپوننت‌های کلیدی**: `chatUI.js`, `messageRenderer.js`, `settingsModal.js`, `sidebarManager.js`.

### 2.2. لایه هسته (Core Layer)

این لایه قلب تپنده برنامه است و هیچ وابستگی مستقیمی به DOM ندارد.

-   **مسئولیت‌ها**:
    -   نگهداری وضعیت کلی برنامه (آرایه‌ای از `chats`، شناسه `activeChatId`، وضعیت `isLoading` و `settings`).
    -   پیاده‌سازی منطق اصلی کسب‌وکار (ایجاد چت جدید، ارسال پیام در چت فعال، حذف چت).
    -   استفاده از **الگوی استراتژی (Strategy Pattern)** برای انتخاب `Provider` مناسب (Gemini, OpenAI, و غیره) بر اساس تنظیمات کاربر.
    -   **انتشار (Publish)** رویدادها از طریق `EventEmitter` برای اطلاع‌رسانی به لایه‌های دیگر (مانند `UI Layer`) در مورد تغییرات وضعیت.
-   **کامپوننت‌های کلیدی**: `chatEngine.js`, `eventEmitter.js`, و تمام فایل‌های موجود در `providers/`.

### 2.3. لایه سرویس‌ها (Services Layer)

این لایه شامل ماژول‌های عمومی و قابل استفاده مجدد است که وظایف خاص و جانبی را انجام می‌دهند.

-   **مسئولیت‌ها**:
    -   **`storageService.js`**: انتزاعی‌سازی عملیات خواندن و نوشتن در `IndexedDB`. این سرویس مدیریت خطاهای پیشرفته (مانند پر شدن حافظه) و همگام‌سازی بین تب‌ها را نیز بر عهده دارد.
    -   **`apiService.js`**: مدیریت تمام ارتباطات شبکه با APIهای خارجی. این سرویس منطق تلاش مجدد (Retry Logic)، وقفه زمانی (Timeout) و پردازش استریم را پیاده‌سازی می‌کند.
    -   **`markdownService.js`**: کپسوله کردن منطق پردازش و رندر متن Markdown به HTML. این کار باعث می‌شود بتوان در آینده به راحتی مفسر Markdown را تغییر داد.
-   **کامپوننت‌های کلیدی**: `apiService.js`, `storageService.js`, `markdownService.js`.

## 3. معماری رویداد-محور (Event-Driven Architecture)

ارتباط اصلی بین `Core Layer` و `UI Layer` از طریق یک سیستم **Publish/Subscribe** ساده (پیاده‌سازی شده در `eventEmitter.js`) انجام می‌شود.

-   **چگونه کار می‌کند؟**
    1.  `UI Layer` در زمان مقداردهی اولیه، خود را به عنوان شنونده (Listener) برای رویدادهای مختلف `chatEngine` ثبت می‌کند (مثلاً `chatEngine.on('chunk', ...)`).
    2.  زمانی که یک عملیات در `Core Layer` رخ می‌دهد (مثلاً یک قطعه جدید از پاسخ استریم‌شده دریافت می‌شود)، `chatEngine` یک رویداد را **منتشر (emit)** می‌کند (مثلاً `chatEngine.emit('chunk', 'hello')`).
    3.  `EventEmitter` تمام شنونده‌های ثبت‌شده برای آن رویداد را فراخوانی کرده و داده‌ها را به آن‌ها ارسال می‌کند.
    4.  `UI Layer` داده‌ها را دریافت کرده و DOM را به‌روزرسانی می‌کند.

-   **مزایا**:
    -   **جداسازی کامل (Decoupling)**: `Core Layer` هیچ اطلاعی از نحوه نمایش داده‌ها ندارد و `UI Layer` هیچ اطلاعی از منطق داخلی ندارد. این به ما اجازه می‌دهد تا هر لایه را به صورت مستقل تغییر دهیم. برای مثال، می‌توانیم کل `UI Layer` را با یک فریمورک مانند React جایگزین کنیم بدون اینکه حتی یک خط از کد `Core Layer` را تغییر دهیم.

## 4. نمودار جریان یک درخواست (Request Flow Diagram)

این نمودار، مراحل کامل از زمان ارسال پیام توسط کاربر تا نمایش پاسخ را نشان می‌دهد:

```
User ---[1. تایپ و ارسال پیام]---> [ChatUI]
  |
  +-----[2. فراخوانی `chatEngine.sendMessage(text)`]---> [ChatEngine]
                                                             |
  +<----[3. انتشار رویداد `loading(true)` و `message(userMessage)`]--+
  |                                                          |
[UI به‌روزرسانی می‌شود: دکمه غیرفعال، پیام کاربر نمایش داده می‌شود]   |
                                                             V
                                                      [Provider Selector]
                                                             |
  +-----[4. انتخاب Provider مناسب (مثلاً Gemini)]---> [GeminiProvider]
                                                             |
  +-----[5. فراخوانی `apiService.fetchStreamWithRetries()`]---> [ApiService]
                                                                    |
                                                     [6. ارسال درخواست به Gemini API]
                                                                    |
  +<----[7. دریافت قطعات استریم (Chunks)]----------------------------+
  |                                                                 |
[ApiService] ---[8. پردازش و ارسال Chunk به Callback]---> [GeminiProvider]
                                                             |
  +<----[9. `onChunk(chunk)` فراخوانی می‌شود]-------------------+
  |                                                          |
[ChatEngine] ---[10. انتشار رویداد `chunk(text)`]---> [EventEmitter]
                                                             |
  +<----[11. `messageRenderer` رویداد را دریافت می‌کند]----------+
  |
[messageRenderer متن خام را انباشته، با `markdownService` رندر کرده و `innerHTML` حباب پیام را به‌روزرسانی می‌کند]

... (مراحل 7 تا 11 برای هر Chunk تکرار می‌شود) ...

[ApiService] ---[12. استریم تمام می‌شود]---> [ChatEngine]
                                               |
  +<---[13. انتشار `loading(false)` و `streamEnd`]--+
  |
[UI به‌روزرسانی می‌شود: دکمه فعال می‌شود]
```
## 5. تصمیمات طراحی و چرایی آن‌ها

-   **Vanilla JS**: برای سبک نگه داشتن پروژه، کاهش وابستگی‌ها و اطمینان از حداکثر کارایی انتخاب شده است.
-   **ماژول‌های ES6**: برای سازماندهی بهتر کد، جداسازی مسئولیت‌ها و قابلیت نگهداری بالا.
-   **جداسازی UI از Core**: این مهم‌ترین تصمیم معماری است. این جداسازی به ما اجازه می‌دهد که به راحتی UI را تغییر دهیم، منطق را تست کنیم و پروژه را در آینده به پلتفرم‌های دیگر (مثلاً یک اپلیکیشن دسکتاپ) گسترش دهیم.
-   **ذخیره‌سازی سمت کلاینت**: برای سادگی و عدم نیاز به بک‌اند، تمام داده‌ها در `IndexedDB` ذخیره می‌شوند. این تصمیم باعث می‌شود برنامه کاملاً ایستا باشد و از ذخیره‌سازی ساختاریافته و پایدارتری نسبت به `localStorage` بهره‌مند شود.
-   **مدیریت چندین چت**: به جای یک تاریخچه واحد، برنامه اکنون مجموعه‌ای از اشیاء چت را مدیریت می‌کند. این کار پیچیدگی مدیریت وضعیت را افزایش می‌دهد اما تجربه کاربری بسیار بهتری را فراهم می‌کند و به کاربران اجازه می‌دهد مکالمات خود را سازماندهی کنند. هر شیء چت شامل شناسه منحصر به فرد، عنوان، پیام‌ها و متادیتای خود است.