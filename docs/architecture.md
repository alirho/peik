# مستندات معماری گوگ (Goug AI Chat)

این سند معماری سطح بالای برنامه چت گوگ، تصمیمات کلیدی طراحی و جریان داده در سیستم را تشریح می‌کند. هدف این است که به توسعه‌دهندگان درک عمیقی از ساختار پروژه بدهد تا بتوانند به طور مؤثر آن را نگهداری و گسترش دهند.

## 1. نمای کلی معماری (Architectural Overview)

برنامه از یک **معماری سه لایه، ماژولار و رویداد-محور (Event-Driven)** در فرانت‌اند پیروی می‌کند. این سه لایه اصلی عبارتند از:

1.  **لایه رابط کاربری (UI Layer)**: مسئولیت تمام جنبه‌های بصری و تعامل با کاربر را بر عهده دارد.
2.  **لایه هسته (Core Layer)**: مغز متفکر برنامه است که منطق اصلی، مدیریت وضعیت و ارتباط با APIهای خارجی را مدیریت می‌کند.
3.  **لایه سرویس‌ها (Services Layer)**: ابزارهای کمکی و انتزاعی را برای نگرانی‌های جانبی مانند ارتباطات شبکه، **پیاده‌سازی‌های ذخیره‌سازی** و پردازش Markdown فراهم می‌کند.

### نمودار معماری

```
+-----------------------------------------------------------------+
| کاربر (User)                                                    |
+-----------------------------------------------------------------+
      ^                                      |
      | User Interactions (clicks, input)      | DOM Updates (render)
      v                                      |
+-----------------------------------------------------------------+
| لایه رابط کاربری (UI Layer)                                     |
| Orchestrator: [chatUI.js]                                       |
| Components: [inputManager.js, messageRenderer.js, ...]          |
| - کامپوننت‌ها رویدادهای کاربر را مدیریت می‌کنند.                 |
| - `chatUI.js` به عنوان ارکستراتور، بین کامپوننت‌ها و هسته هماهنگی ایجاد می‌کند.|
| - به رویدادهای `ChatEngine` گوش داده و کامپوننت‌ها را به‌روز می‌کند.|
+-----------------------------------------------------------------+
      ^                                      |
      | Calls `chatEngine.sendMessage()`     | Emits Events (`message`, `chunk`, `error`)
      | `chatEngine.switchActiveChat()`      |
      v                                      |
+-----------------------------------------------------------------+
| لایه هسته (Core Layer)                                          |
| Orchestrator: [chatEngine.js]                                   |
| Modules: [chatManager.js, messageHandler.js, ...]               |
| - `chatEngine.js` وضعیت اصلی را نگه داشته و وظایف را واگذار می‌کند.|
| - هر ماژول یک مسئولیت خاص دارد (مدیریت چت، پیام، ذخیره، همگام‌سازی).|
| - از طریق تزریق وابستگی با لایه سرویس‌ها کار می‌کند.            |
+-----------------------------------------------------------------+
      |                                      ^
      | Calls `storage.saveChat()` / `apiService.fetch()` | Returns Data
      v                                      |
+-----------------------------------------------------------------+
| لایه سرویس‌ها (Services Layer)                                   |
| [apiService.js, storageService.js, markdownService.js]          |
| - انتزاعی‌سازی ارتباط با APIهای خارجی (fetch).                   |
| - ارائه پیاده‌سازی‌های مختلف برای ذخیره‌سازی داده‌ها.              |
| - پردازش و رندر متن Markdown.                                   |
+-----------------------------------------------------------------+
```

## 2. تشریح لایه‌ها

### 2.1. لایه رابط کاربری (UI Layer)

این لایه از یک **الگوی ارکستراتور-کامپوننت** پیروی می‌کند.

-   **`chatUI.js` (ارکستراتور)**: مسئولیت اصلی آن هماهنگی بین کامپوننت‌های مختلف UI و لایه هسته است. این کلاس کامپوننت‌ها را نمونه‌سازی کرده، رویدادهای `ChatEngine` را به آن‌ها متصل می‌کند و جریان اصلی UI را مدیریت می‌کند.
-   **کامپوننت‌ها (`components/*.js`)**: هر کامپوننت یک بخش خاص از UI را با مسئولیت مشخص مدیریت می‌کند. برای مثال:
    -   **`InputManager`**: مدیریت کامل ناحیه ورودی کاربر.
    -   **`SidebarManager`**: مدیریت لیست چت‌ها و سایدبار.
    -   **`MessageRenderer`**: رندر کردن پیام‌ها در صفحه.

### 2.2. لایه هسته (Core Layer)

این لایه نیز از یک **الگوی ارکستراتور-ماژول** پیروی می‌کند و هیچ وابستگی مستقیمی به DOM ندارد.

-   **`chatEngine.js` (ارکستراتور)**: قلب تپنده برنامه است. این کلاس وضعیت اصلی (state) را نگهداری می‌کند، ماژول‌ها را نمونه‌سازی می‌کند، به عنوان هاب مرکزی رویدادها عمل می‌کند و فراخوانی‌های API عمومی را به ماژول مربوطه **واگذار (Delegate)** می‌کند.
-   **ماژول‌ها (`modules/*.js`)**: هر ماژول یک مسئولیت اصلی و مشخص را کپسوله می‌کند:
    -   **`ChatManager`**: مدیریت عملیات مربوط به چت‌ها (ایجاد، حذف، تغییر نام).
    -   **`MessageHandler`**: مدیریت فرآیند ارسال پیام.
    -   **`StorageManager`**: پیاده‌سازی منطق ذخیره‌سازی هوشمند (تلاش مجدد، صف موقت).
    -   **`SyncManager`**: همگام‌سازی بین تب‌ها.

### 2.3. لایه سرویس‌ها (Services Layer)

این لایه شامل ماژول‌های عمومی و قابل استفاده مجدد است که وظایf خاص و جانبی را انجام می‌دهند و به لایه‌های دیگر تزریق می‌شوند.

-   **`storageService.js`**: یک **پیاده‌سازی** از رابط ذخیره‌سازی است که از `IndexedDB` استفاده می‌کند.
-   **`apiService.js`**: مدیریت تمام ارتباطات شبکه با APIهای خارجی.
-   **`markdownService.js`**: کپسوله کردن منطق پردازش و رندر متن Markdown به HTML.

## 3. معماری رویداد-محور (Event-Driven Architecture)

ارتباط اصلی بین `Core Layer` و `UI Layer` از طریق یک سیستم **Publish/Subscribe** ساده (پیاده‌سازی شده در `eventEmitter.js`) انجام می‌شود. این رویکرد جداسازی کامل (Decoupling) لایه‌ها را تضمین می‌کند.

## 4. نمودار جریان یک درخواست (Request Flow Diagram)

این نمودار، مراحل کامل از زمان ارسال پیام توسط کاربر تا نمایش پاسخ در معماری جدید را نشان می‌دهد:

```
User ---[1. تایپ و ارسال]--> [InputManager]
  |
  +-----[2. فراخوانی `chatUI.handleSendMessage()`]---> [ChatUI]
                                                          |
  +-----[3. فراخوانی `chatEngine.sendMessage()`]---> [ChatEngine]
                                                          |
  +-----[4. واگذاری به `messageHandler.sendMessage()`]--> [MessageHandler]
                                                          |
  +<----[5. انتشار رویداد `loading(true)` و `message(userMessage)`]--+
  |
[UI به‌روزرسانی می‌شود: دکمه غیرفعال، پیام کاربر نمایش داده می‌شود]
  |
  V
[MessageHandler] ---[6. انتخاب Provider و فراخوانی]---> [Provider]
                                                          |
  +-----[7. فراخوانی `apiService.fetchStream()`]---> [ApiService]
  |
  ... (استریم و انتشار رویداد `chunk`)...
  |
  V
[MessageHandler] ---[8. پس از اتمام استریم]--> [StorageManager]
                                                          |
  +-----[9. فراخوانی `storageManager.save(chat)`]---> [StorageService]
  |
  V
[MessageHandler] ---[10. انتشار `loading(false)` و `streamEnd`]--> [ChatEngine]
  |
[UI به‌روزرسانی می‌شود: دکمه فعال می‌شود]
```

## 5. تصمیمات طراحی و چرایی آن‌ها

-   **Vanilla JS**: برای سبک نگه داشتن پروژه، کاهش وابستگی‌ها و اطمینان از حداکثر کارایی انتخاب شده است.
-   **معماری ماژولار (Orchestrator/Module Pattern)**: بازسازی اخیر، کلاس‌های بزرگ `ChatEngine` و `ChatUI` را به ماژول‌ها و کامپوننت‌های کوچکتر با مسئولیت واحد تقسیم کرد. این کار خوانایی، قابلیت نگهداری و توسعه‌پذیری کد را به شدت افزایش می‌دهد.
-   **جداسازی UI از Core**: این مهم‌ترین تصمیم معماری است که اجازه می‌دهد منطق برنامه در محیط‌های مختلف (مرورگر، Node.js) بدون تغییر استفاده شود.
-   **آداپتور ذخیره‌سازی (Storage Adapter Pattern)**: به جای وابستگی مستقیم به `IndexedDB`، هسته برنامه یک رابط (Interface) ذخیره‌سازی را انتظار دارد. این یک نمونه عالی از **تزریق وابستگی (Dependency Injection)** است.