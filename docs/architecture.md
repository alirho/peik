# مستندات معماری گوگ (Goug AI Chat)

این سند معماری سطح بالای برنامه چت گوگ، تصمیمات کلیدی طراحی و جریان داده در سیستم را تشریح می‌کند. هدف این است که به توسعه‌دهندگان درک عمیقی از ساختار پروژه بدهد تا بتوانند به طور مؤثر آن را نگهداری و گسترش دهند.

## 1. نمای کلی معماری (Architectural Overview)

برنامه از یک **معماری سه لایه، ماژولار و رویداد-محور (Event-Driven)** در فرانت‌اند پیروی می‌کند. این سه لایه اصلی عبارتند از:

1.  **لایه رابط کاربری (UI Layer)**: مسئولیت تمام جنبه‌های بصری و تعامل با کاربر را بر عهده دارد.
2.  **لایه هسته (Core Layer)**: مغز متفکر برنامه است که منطق اصلی، مدیریت وضعیت و ارتباط با APIهای خارجی را مدیریت می‌کند.
3.  **لایه سرویس‌ها (Services Layer)**: ابزارهای کمکی و انتزاعی را برای نگرانی‌های جانبی مانند ارتباطات شبکه، **پیاده‌سازی‌های ذخیره‌سازی** و پردازش Markdown فراهم می‌کند.

### نمودار معماری

```
+-----------------------------------------------------------------+
| کاربر (User)                                                    |
+-----------------------------------------------------------------+
      ^                                      |
      | User Interactions (clicks, input)      | DOM Updates (render)
      v                                      |
+-----------------------------------------------------------------+
| لایه رابط کاربری (UI Layer)                                     |
| Orchestrator: [chatUI.js]                                       |
| Components: [inputManager.js, messageRenderer.js, ...]          |
| - کامپوننت‌ها رویدادهای کاربر را مدیریت می‌کنند.                 |
| - `chatUI.js` به عنوان ارکستراتور، بین کامپوننت‌ها و هسته هماهنگی ایجاد می‌کند.|
| - به رویدادهای `ChatEngine` گوش داده و کامپوننت‌ها را به‌روز می‌کند.|
+-----------------------------------------------------------------+
      ^                                      |
      | Calls `chatEngine.sendMessage()`     | Emits Events (`message`, `chunk`, `error`)
      | `chatEngine.switchActiveChat()`      |
      v                                      |
+-----------------------------------------------------------------+
| لایه هسته (Core Layer)                                          |
| Orchestrator: [chatEngine.js]                                   |
| Modules: [chatManager.js, messageHandler.js, ...]               |
| - `chatEngine.js` وضعیت اصلی را نگه داشته و وظایف را واگذار می‌کند.|
| - هر ماژول یک مسئولیت خاص دارد (مدیریت چت، پیام، ذخیره، همگام‌سازی).|
| - از طریق تزریق وابستگی با لایه سرویس‌ها کار می‌کند.            |
+-----------------------------------------------------------------+
      |                                      ^
      | Calls `storage.saveChat()` / `apiService.fetch()` | Returns Data
      v                                      |
+-----------------------------------------------------------------+
| لایه سرویس‌ها (Services Layer)                                   |
| [apiService.js, indexedDBStorage.js, markdownService.js]        |
| - انتزاعی‌سازی ارتباط با APIهای خارجی (fetch).                   |
| - ارائه پیاده‌سازی‌های مختلف برای ذخیره‌سازی داده‌ها.              |
| - پردازش و رندر متن Markdown.                                   |
+-----------------------------------------------------------------+
```

## 2. تشریح لایه‌ها

### 2.1. لایه رابط کاربری (UI Layer)

این لایه از یک **الگوی ارکستراتور-کامپوننت** پیروی می‌کند.

-   **`chatUI.js` (ارکستراتور)**: مسئولیت اصلی آن هماهنگی بین کامپوننت‌های مختلف UI و لایه هسته است. این کلاس کامپوننت‌ها را نمونه‌سازی کرده، رویدادهای `ChatEngine` را به آن‌ها متصل می‌کند و جریان اصلی UI را مدیریت می‌کند.
-   **کامپوننت‌ها (`components/*.js`)**: هر کامپوننت یک بخش خاص از UI را با مسئولیت مشخص مدیریت می‌کند. برای مثال:
    -   **`InputManager`**: مدیریت کامل ناحیه ورودی کاربر.
    -   **`SidebarManager`**: مدیریت لیست چت‌ها و سایدبار.
    -   **`MessageRenderer`**: رندر کردن پیام‌ها در صفحه.

### 2.2. لایه هسته (Core Layer)

این لایه نیز از یک **الگوی ارکستراتور-ماژول** پیروی می‌کند و هیچ وابستگی مستقیمی به DOM ندارد.

-   **`chatEngine.js` (ارکستراتور)**: قلب تپنده برنامه است. این کلاس وضعیت اصلی (state) را نگهداری می‌کند، ماژول‌ها را نمونه‌سازی می‌کند، به عنوان هاب مرکزی رویدادها عمل می‌کند و فراخوانی‌های API عمومی را به ماژول مربوطه **واگذار (Delegate)** می‌کند.
-   **ماژول‌ها (`modules/*.js`)**: هر ماژول یک مسئولیت اصلی و مشخص را کپسوله می‌کند:
    -   **`ChatManager`**: مدیریت عملیات مربوط به چت‌ها (ایجاد، حذف، تغییر نام).
    -   **`MessageHandler`**: مدیریت فرآیند ارسال پیام (شامل لغو درخواست‌های قبلی).
    -   **`StorageManager`**: پیاده‌سازی منطق ذخیره‌سازی هوشمند (تلاش مجدد، صف موقت).
    -   **`SyncManager`**: همگام‌سازی بین تب‌ها.

### 2.3. لایه سرویس‌ها (Services Layer)

این لایه شامل ماژول‌های عمومی و قابل استفاده مجدد است که وظایf خاص و جانبی را انجام می‌دهند و به لایه‌های دیگر تزریق می‌شوند.

-   **`indexedDBStorage.js`**: یک **پیاده‌سازی** از رابط ذخیره‌سازی است که از `IndexedDB` استفاده می‌کند.
-   **`apiService.js`**: مدیریت تمام ارتباطات شبکه با APIهای خارجی.
-   **`markdownService.js`**: کپسوله کردن منطق پردازش و رندر متن Markdown به HTML.

### 2.4. چرخه حیات و پاک‌سازی (Lifecycle and Cleanup)
برای جلوگیری از نشت حافظه (Memory Leaks) و اطمینان از عملکرد پایدار برنامه در بلندمدت، تمام کامپوننت‌های اصلی در لایه‌های UI و Core از یک الگوی چرخه حیات ساده پیروی می‌کنند:

-   **`init()`**: یک متد `async` که مسئولیت راه‌اندازی اولیه کامپوننت، بارگذاری داده‌ها، کش کردن المان‌های DOM و اتصال شنوندگان رویداد (Event Listeners) را بر عهده دارد.
-   **`destroy()`**: متدی که مسئولیت پاک‌سازی کامل کامپوننت را دارد. این متد تمام شنوندگان رویدادی که توسط کامپوننت ایجاد شده‌اند را حذف می‌کند، تایمرها (مانند `setInterval`) را پاک می‌کند، و هر منبع دیگری (مانند `BroadcastChannel`) را آزاد می‌کند.

این الگو تضمین می‌کند که وقتی کاربر صفحه را می‌بندد یا از آن خارج می‌شود، هیچ فرآیند پس‌زمینه‌ای یا شنونده رویدادی در حافظه باقی نمی‌ماند.

## 3. معماری رویداد-محور (Event-Driven Architecture)

ارتباط اصلی بین `Core Layer` و `UI Layer` از طریق یک سیستم **Publish/Subscribe** ساده (پیاده‌سازی شده در `eventEmitter.js`) انجام می‌شود. این رویکرد جداسازی کامل (Decoupling) لایه‌ها را تضمین می‌کند.

## 4. نمودار جریان یک درخواست (Request Flow Diagram)

این نمودار، مراحل کامل از زمان ارسال پیام توسط کاربر تا نمایش پاسخ در معماری جدید را نشان می‌دهد:

```
User ---[1. تایپ و ارسال]--> [InputManager]
  |
  +-----[2. فراخوانی `chatUI.handleSendMessage()`]---> [ChatUI]
                                                          |
  +-----[3. فراخوانی `chatEngine.sendMessage()`]---> [ChatEngine]
                                                          |
  +-----[4. واگذاری به `messageHandler.sendMessage()`]--> [MessageHandler]
  |
  +<----[5. انتشار رویداد `loading(true)` و `message(userMessage)`]--+
  |
[UI به‌روزرسانی می‌شود: دکمه غیرفعال، پیام کاربر نمایش داده می‌شود]
  |
  V
[MessageHandler] ---[6. استخراج پیکربندی با `resolveProviderConfig()`]
  |
  V
[MessageHandler] ---[7. انتخاب Provider و فراخوانی]---> [Provider]
                                                          |
  +-----[8. فراخوانی `apiService.fetchStream()`]---> [ApiService]
  |
  ... (استریم و انتشار رویداد `chunk`)...
  |
  V
[MessageHandler] ---[9. پس از اتمام استریم]--> [StorageManager]
                                                          |
  +-----[10. فراخوانی `storageManager.save(chat)`]---> [StorageService]
  |
  V
[MessageHandler] ---[11. انتشار `loading(false)` و `streamEnd`]--> [ChatEngine]
  |
[UI به‌روزرسانی می‌شود: دکمه فعال می‌شود]
```

## 5. تصمیمات طراحی و چرایی آن‌ها

-   **Vanilla JS**: برای سبک نگه داشتن پروژه، کاهش وابستگی‌ها و اطمینان از حداکثر کارایی انتخاب شده است.
-   **معماری ماژولار (Orchestrator/Module Pattern)**: بازسازی اخیر، کلاس‌های بزرگ `ChatEngine` و `ChatUI` را به ماژول‌ها و کامپوننت‌های کوچکتر با مسئولیت واحد تقسیم کرد. این کار خوانایی، قابلیت نگهداری و توسعه‌پذیری کد را به شدت افزایش می‌دهد.
-   **جداسازی UI از Core**: این مهم‌ترین تصمیم معماری است که اجازه می‌دهد منطق برنامه در محیط‌های مختلف (مرورگر، Node.js) بدون تغییر استفاده شود.
-   **آداپتور ذخیره‌سازی (Storage Adapter Pattern)**: به جای وابستگی مستقیم به `IndexedDB`، هسته برنامه یک رابط (Interface) ذخیره‌سازی را انتظار دارد. این یک نمونه عالی از **تزریق وابستگی (Dependency Injection)** است.
-   **بارگذاری درخواستی (Lazy Loading)**: به جای بارگذاری تمام تاریخچه گفتگوها در ابتدای کار، برنامه ابتدا فقط لیست گفتگوها را بارگذاری می‌کند. سپس، پیام‌های هر گفتگو تنها زمانی که کاربر آن را برای مشاهده انتخاب کند، از پایگاه داده خوانده می‌شود. این رویکرد به طور چشمگیری سرعت راه‌اندازی اولیه را افزایش داده و مصرف حافظه را کاهش می‌دهد، به خصوص زمانی که کاربر تاریخچه گفتگوهای زیادی دارد.
-   **مدیریت چرخه حیات درخواست (Request Lifecycle Management)**: برای جلوگیری از Race Condition و دریافت پاسخ‌های قدیمی در گپ‌های اشتباه، برنامه از `AbortController` برای مدیریت چرخه حیات درخواست‌ها استفاده می‌کند. قبل از ارسال هر پیام جدید یا هنگام جابجایی بین گپ‌ها، هر درخواست در حال اجرایی به صورت هوشمند لغو می‌شود. این رویکرد پایداری برنامه را افزایش داده و از هدر رفت منابع جلوگیری می‌کند.
-   **ذخیره‌سازی مبتنی بر مرجع (Reference-based Model Storage)**: در نسخه‌های اولیه، هر گپ یک کپی کامل از پیکربندی مدل (شامل کلید API) را ذخیره می‌کرد. این رویکرد به دلایل امنیتی و کارایی بازنگری شد. اکنون، هر گپ فقط یک **مرجع (Reference)** به مدل (شامل شناسه و نام) را ذخیره می‌کند. در زمان ارسال پیام، `ChatEngine` این مرجع را با تنظیمات فعلی کاربر تطبیق داده و پیکربندی کامل را در لحظه استخراج می‌کند. این معماری:
    -   **امنیت را افزایش می‌دهد**: کلیدهای API دیگر در تاریخچه گفتگوها تکرار نمی‌شوند.
    -   **قابلیت نگهداری را بهبود می‌بخشد**: با به‌روزرسانی یک کلید API در تنظیمات، تمام گپ‌های مرتبط به صورت خودکار از آن استفاده می‌کنند.
    -   **حجم ذخیره‌سازی را کاهش می‌دهد**.
    -   برنامه شامل یک **مکانیسم مهاجرت خودکار** است تا گپ‌های ایجاد شده با ساختار قدیمی را به فرمت جدید تبدیل کند.